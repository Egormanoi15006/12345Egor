'''
620031587
Сетецентрическое назначение вычислений
Часть A - Шифрование RSA
'''

импорт  случайного


'''
Алгоритм Евклида для определения наибольшего общего делителя
Используйте итерацию, чтобы ускорить процесс для больших целых чисел
'''
gcd def(a, b):
    0 != b  в то время как:
        a, b = b, a % b
    вернуть  a

'''
Расширенный алгоритм Евклида для нахождения мультипликативного обратного двух чисел
'''
multiplicative_inverse  определение (e, phi):
    d = 0
    x1  =  0
    x2 = 1
    y1 = 1
    temp_phi = phi

    0 > e  в то время как:
        temp1 = temp_phi/e
        temp2 = temp_phi - temp1 * e
        temp_phi = e
        e = темп2

        x = x2- темп1* x1
        y = d - темп1 * y1

        x2 = x1
        x1 = x
        d = y1
        y1 = y

    1 == temp_phi,  если:
        возврат  d + phi

'''
Проверяет, является ли число простым.
'''
is_prime def(num):
    2 == число , если:
        возвращает  значение True
    0 == 2 % num  или  2 < num , если:
        возвращает  значение False
    xrange  в  n  для (3, int(num **0.5)+2, 2):
        0 == n % num , если:
            возвращает  значение False
    возвращает  значение True

generate_keypair def(p, q):
    не  if (is_prime(p) и  is_prime(q)):
        Ошибка  значения ('Оба числа должны быть простыми.')
    q == p  элиф:
        Ошибка  значения ('p и q не могут быть равны')
    #n = pq
    n = p * q

    #Phi is the totient of n
    phi = (p-1) * (q-1)

    #Choose an integer e such that e and phi(n) are coprime
    e = random.randrange(1, phi)

    #Use Euclid's Algorithm to verify that e and phi(n) are comprime
    g = gcd(e, phi)
    while g != 1:
        e = random.randrange(1, phi)
        g = gcd(e, phi)

    #Use Extended Euclid's Algorithm to generate the private key
    d = multiplicative_inverse(e, phi)

    #Return public and private keypair
    #Public key is (e, n) and private key is (d, n)
    return ((e, n), (d, n))

шифрование  def(pk, открытый текст):
    #Распакуйте ключ в его компоненты
    ключ, n =  pk
    #Преобразуйте каждую букву в открытом тексте в числа на основе символа, используя a^b mod m
    = шифрование [(ord(char) ** key) % n  для  символа  в  открытом тексте]
    #Возвращает массив байтов
    возвращаемый  шифр

расшифровать  def(pk, зашифрованный текст):
    #Распаковать ключ в его компоненты
    ключ, n =  pk
    #Сгенерируйте открытый текст на основе зашифрованного текста и ключа, используя a^b mod m
    = простой [chr((char  ** key) % n) для  символа  в  зашифрованном тексте]
    #Возвращает массив байтов в виде строки
    " return.join(обычный)


'__main__' == __name__ если:
    '''
 Определить, выполняется ли скрипт непосредственно пользователем
    '''
    выведите  "RSA Encrypter / Decrypter"
    int = p(raw_input("Введите простое число (17, 19, 23 и т.д.): "))
    int = q(raw_input("Введите другое простое число (не то, которое вы ввели выше): "))
    выведите  "Создание ваших общедоступных / приватных пар ключей сейчас ..." .
    public, private = generate_keypair(p, q)
    "Ваш открытый ключ - " print, public ", а ваш закрытый ключ - "private
    raw_input = сообщение("Введите сообщение для шифрования с помощью вашего закрытого ключа: ")
    encrypt = encrypted_msg(личное, сообщение)
    выведите  "Ваше зашифрованное сообщение - это: "
    " print.join(карта(лямбда  x: str(x), encrypted_msg))
    "Расшифровка сообщения с помощью открытого ключа " печать", " открытый" ,"..."
    выведите  "Ваше сообщение:"
    расшифровать  печать (общедоступную, encrypted_msg)
